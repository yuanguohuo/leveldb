// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <algorithm>
#include <cstdint>
#include <vector>

#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

// Yuanguo: why split the entries into "restarts"? 
//   one reason is to make `Block::Iter::Prev()` cheaper, see it below;
//
// Yuanguo:
//
//               data_  ----------->  +================================================+ <--------+
//                                    |                     Entry                      |          |
//                                    |                     Entry                      |          |
//                                    |                     ......                     |          |
//                                    |                     Entry                      |          |
//                                    +================================================+ <--------+-----+
//                                    |                     Entry                      |          |     |
//                                    |                     Entry                      |          |     |
//                                    |                     ......                     |          |     |
//                                    |                     Entry                      |          |     |
//                                    +================================================+          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    |                                                |          |     |
//                                    +================================================+ <--------+-----+-----+
//                                    |                     Entry                      |          |     |     |
//                                    |                     Entry                      |          |     |     |
//                                    |                     ......                     |          |     |     |
//                                    |                     Entry                      |          |     |     |
// data_ + restart_offset_  ------->  +================================================+          |     |     |
//                                    |              restart[0]                        | ---------+     |     |
//                                    +------------------------------------------------+                |     |
//                                    |              restart[1]                        | ---------------+     |
//                                    +------------------------------------------------+                      |
//                                    |              ......                            |                      |
//                                    +------------------------------------------------+                      |
//                                    |              restart[NumRestarts-1]            | ---------------------+
//                                    +------------------------------------------------+
//                                    |              NumRestarts (Fixed32)             |
//         data_ + size_  --------->  +================================================+

inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    //Yuanguo: 假如前面没有Entry，Block的全部空间就是 restart数组+数组的大小(NumRestarts)，这样最多
    //  有max_restarts_allowed个restarts。
    //  显然NumRestarts不能大于它；否则，就是data corrupted了；
    size_t max_restarts_allowed = (size_ - sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      //Yuanguo: 多减一个1，代表NumRestarts占用的一个uint32_t;
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

//Yuanguo: Entry (shared between what and what? between one key and previous key)
//
//   fast path:
//               +------------------------------------------------+    <---- p before decode
//               |    shared key bytes (1 byte < 128)             |
//               +------------------------------------------------+
//               |    non shared key bytes (1 byte < 128)         |
//               +------------------------------------------------+
//               |    value length (1 byte < 128)                 |
//               +------------------------------------------------+    <----  p after decode
//               |                                                |
//               |                 non shared key                 |
//               |                                                |
//               +------------------------------------------------+
//               |                                                |
//               |                                                |
//               |                      value                     |
//               |                                                |
//               |                                                |
//               |                                                |
//               +------------------------------------------------+    <---- limit
//
//
//   non fast path:
//
//               +------------------------------------------------+    <---- p before decode
//               |    shared key bytes (var int 32)               |
//               +------------------------------------------------+
//               |    non shared key bytes (var int 32)           |
//               +------------------------------------------------+
//               |    value length (var int32)                    |
//               +------------------------------------------------+    <----  p after decode
//               |                                                |       
//               |                 non shared key                 |
//               |                                                |
//               +------------------------------------------------+ 
//               |                                                |
//               |                                                |
//               |                      value                     |
//               |                                                |
//               |                                                |
//               |                                                |
//               +------------------------------------------------+    <---- limit
//

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns nullptr.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared, uint32_t* non_shared,
                                      uint32_t* value_length) {
  //Yuanguo: p到limit之间有：shard key bytes (至少1B)，non_shared key bytes (至少1B)，value length (至少1B)，
  //  所以 limit - p < 3表示数据是invalid，返回nullptr;
  if (limit - p < 3) return nullptr;
  *shared = reinterpret_cast<const uint8_t*>(p)[0];
  *non_shared = reinterpret_cast<const uint8_t*>(p)[1];
  *value_length = reinterpret_cast<const uint8_t*>(p)[2];
  //Yuanguo: 最高位全部为0，表示都是 shard key bytes, non_shared key bytes和value length都是1B；
  //  否则，它们就都是4B(32bit)的；
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) return nullptr;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return nullptr;
  }
  return p;
}

class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;       // underlying block contents
  uint32_t const restarts_;      // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_;  // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls

  // Yuanguo: when iterating, `key_` stores the "key bytes" of current entry;
  //     +------------------+-----------------------------------------+
  //     |   shared-bytes   |            non-shared-bytes             |
  //     +------------------+-----------------------------------------+
  //
  // Yuanguo: for the 1st entry of every "restart", "shared-bytes" is 0 (see function BlockBuilder::Add()), this is significant
  //   for iterating:
  //       a. when start iterating at the 1st entry of a "restart", `key_` is complete (because there is no shared bytes);
  //       b. when `Next()` is called, `key_` is kept complete (containing shared-bytes and non-shared-bytes) by:
  //                        key_.resize(shared);
  //                        key_.append(p, non_shared);
  //          see function `ParseNextKey` below;
  //       c. we always seek to the 1st entry of a "restart", see Seek, SeekToFirst and SeekToLast; so `key_` is always kept complete
  //          while iterating; this is true even for `Prev()`, because it works like this:
  //                        1. seek to a "restart" < `current_`;
  //                        2. parse keys in the "restart" one by one;
  std::string key_;

  // Yuanguo: when iterating, `value_` points to the "value bytes" of current entry within the block; unlike `key_`, 
  //   it doesn't store, but just points to the bytes (see class Slice);
  //
  // NOTICE: right after SeekToRestartPoint, `value_` doesn't point to the "value bytes", but point to
  //   the start-point of current entry with size = 0; then ParseNextKey() is called, which makes `value_` right!
  //   Plus, ParseNextKey() will try to skip "value bytes" first, and then start parsing; right after SeekToRestartPoint, nothing is skipped 
  //   because value size = 0; And when Next() is called, it skips "value bytes of prev entry" and parses current;
  //
  //Yuanguo: SeekToRestartPoint之后：
  //  - key是空的；
  //  - value_指向本Restart的开始处，且size=0；
  //这是为了满足循环不变式：
  //   当前Iter指向Entry-P，调用ParseNextKey()去Parse Entry-P+1之前，key_和value_总能满足：
  //       1. key_是Entry-P的完整的key；
  //       2. value_指向Entry-P的value起始地址，且长度正确；
  //   只有满足这2个条件(循环不变式)，ParseNextKey()才能正确地解析Entry-P+1。迭代的过程中，一直满足。见ParseNextKey()的实现。
  //   SeekToRestartPoint之后，是满足这2个条件的，只不过Entry-P是一个空Entry (key_和value_都是空的)。Iter指向这个空的Entry-P的状态，
  //   外部是不可见的，因为SeekToRestartPoint()之后，总是立即ParseNextKey()，见Seek, SeekToFirst, SeekToLast，都是seek之后，立即ParseNextKey()。
  //   所以，Iter的user，构造一个Iter，调用Seek/SeekToFirst/SeekToLast之一之后，Iter就指向了一个合法的Entry(如果存在)。
  //
  //   换言之，SeekToRestartPoint之后，是一个"内部的"、"临时的"状态，它指向一个空的、虚拟的、不存在的Entry，但满足循环不变式。然后立即调用
  //   ParseNextKey()，是Iter进入一个外部可见的状态(指向Restart的第一个Entry)。
  //
  //   right after SeekToRestartPoint:
  //
  //               +------------------------------------------------+ <---- value_ (size = 0), nothing will be skipped
  //               |    shared key bytes (1 byte < 128)             |       and parsing will be started here
  //               +------------------------------------------------+
  //               |    non shared key bytes (1 byte < 128)         |
  //               +------------------------------------------------+
  //               |    value length (1 byte < 128)                 |
  //               +------------------------------------------------+ 
  //               |                                                |
  //               |                 non shared key                 |
  //               |                                                |
  //               +------------------------------------------------+
  //               |                                                |
  //               |                                                |
  //               |                      value                     |
  //               |                                                |
  //               |                                                |
  //               |                                                |
  //               +------------------------------------------------+ 
  //
  //
  //   during iterating:
  //
  //      ----->   +================================================+ 
  //        ^      |    shared key bytes (1 byte < 128)             |
  //        |      +------------------------------------------------+
  //        |      |    non shared key bytes (1 byte < 128)         |
  //        |      +------------------------------------------------+
  //        |      |    value length (1 byte < 128)                 |
  //        |      +------------------------------------------------+ 
  //        |      |                                                |
  //   prev entry  |                 non shared key                 |
  //        |      |                                                |
  //        |      +------------------------------------------------+ <---- value_ (size = value-len), value bytes will be 
  //        |      |                                                |       skipped and parsing will be started at p
  //        |      |                                                |
  //        |      |                      value                     |
  //        |      |                                                |
  //        |      |                                                |
  //        V      |                                                |
  //      ----->   +================================================+ <---- p  
  //        ^      |    shared key bytes (1 byte < 128)             |
  //        |      +------------------------------------------------+
  //        |      |    non shared key bytes (1 byte < 128)         |
  //        |      +------------------------------------------------+
  //        |      |    value length (1 byte < 128)                 |
  //        |      +------------------------------------------------+    
  //        |      |                                                |
  //  curr entry   |                 non shared key                 |
  //        |      |                                                |
  //        |      +------------------------------------------------+
  //        |      |                                                |
  //        |      |                                                |
  //        |      |                      value                     |
  //        |      |                                                |
  //        |      |                                                |
  //        V      |                                                |
  //     ------>   +------------------------------------------------+    
  Slice value_;

  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator, const char* data, uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  bool Valid() const override { return current_ < restarts_; }
  Status status() const override { return status_; }
  Slice key() const override {
    assert(Valid());
    return key_;
  }
  Slice value() const override {
    assert(Valid());
    return value_;
  }

  void Next() override {
    assert(Valid());
    ParseNextKey();
  }

  // Yuanguo: `Prev()` is more expensive than `Next()`: 
  //      1. seek to a "restart" < `current_`;
  //      2. parse keys in the "restart" one by one;
  // by default, a "restart" contains 16 keys, thus 15 parses (at most) are needed;
  void Prev() override {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // Yuanguo: mark it as invalid;
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  //Yuanguo: 在Block内找第一个 >= target 的kv-pair； 
  //Yuanguo: `target` is the non shared part of the key.
  //Yuanguo: NO!!!! this is not true: for the 1st entry of every "restart", "shared-bytes" is always 0, so `target`
  //         is the complete key or prefix;
  void Seek(const Slice& target) override {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      //Yuanguo: 解析第mid个Restart的第一个Entry (其key一定是完整的，不和前面有公共部分)；
      const char* key_ptr =
          DecodeEntry(data_ + region_offset, data_ + restarts_, &shared,
                      &non_shared, &value_length);

      // Yuanguo: why shared must be 0?
      //   for the 1st entry of every "restart", "shared-bytes" is always 0 (see function BlockBuilder::Add()); this is 
      //   significant for iterating, see my comments for `Block::Iter::key_` above;
      if (key_ptr == nullptr || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        left = mid;
      } else {
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        right = mid - 1;
      }
    }

    //Yuanguo: 上面的while循环结束时，
    //
    //case-1: mid=X+1, left = right = X
    //     +---------------+   +-----------------+
    //     |   Restart-X   |   |   Restart-X+1   |
    //     +---------------+   +-----------------+
    //              ^
    //              |
    //            target
    //
    //case-2: mid=X+1, left = right = X, 和case-1一样；
    //     +---------------+   +-----------------+
    //     |   Restart-X   |   |   Restart-X+1   |
    //     +---------------+   +-----------------+
    //                       ^
    //                       |
    //                     target
    //
    //case-3: mid=1, left = right = 0；
    //     +---------------+   +-----------------+
    //     |   Restart-0   |   |   Restart-1     |
    //     +---------------+   +-----------------+
    //   ^ 
    //   |
    // target
    //
    //case-4: mid=Max, left = right = Max；
    //     +---------------+   +-----------------+
    //     | Restart-Max-1 |   |  Restart-Max    |
    //     +---------------+   +-----------------+
    //                                              ^ 
    //                                              |
    //                                            target
    //
    //所以，无论那种情况，都要在Restart[left]中寻找。

    // Linear search (within restart block) for first key >= target
    // Yuanguo: SeekToRestartPoint()之后，总是紧接着ParseNextKey();
    SeekToRestartPoint(left);
    while (true) {
      if (!ParseNextKey()) {
        //Yuanguo: ParseNextKey()返回了false；此时本函数返回，Iter是一个invalid状态；
        return;
      }
      if (Compare(key_, target) >= 0) {
        //Yuanguo: Iter指向第一个 >=target 的Entry；
        return;
      }
    }
  }

  void SeekToFirst() override {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  void SeekToLast() override {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  bool ParseNextKey() {
    // Yuanguo: skip "value bytes" of previous entry, return starting-offset of current entry, 
    //   that is previous value_.data() + previous value_.size() - data_;
    // NOTICE: if right after SeekToRestartPoint, previous value_.size() is 0 thus nothing is skipped;
    // See my contents for Block::Iter::value_;
    current_ = NextEntryOffset();

    // Yuanguo: `p` is the starting point of current entry;
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      // Yuanguo: 见Valid(): return current_ < restarts_; 这里让它们相等，就是invalid;
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == nullptr || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      // Yuanguo: `key_` is kept complete while iterating, because:
      //    1. for the 1st entry in every "restart", there's no shared-bytes, so the first key_ is complete;
      //    2. subsequent key_ is kept complete by the following 2 lines: 
      //           a. truncate the suffix, keeping the shared bytes only;
      //           b. append the non shared bytes;
      //    3. envn if for `Prev()`, key_ is kept complete, because it works by
      //           a. seek to a "restart" < `current_`;
      //           b. parse keys in the "restart" one by one;
      //    also see my comments for `Block::Iter::key_` above;
      //
      // Yuanguo: 见前面的"循环不变式"：调用ParseNextKey()之前，循环不变式应该保证成立。

      // Yuanguo: truncate the suffix, keeping the shared bytes only;
      key_.resize(shared);
      // Yuanguo: append the non shared bytes;
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      // Yuanguo: update restart_index_。restart_index_和current_的关系有两种情况：
      //       - current_ 指向Restart[X]的第一个Entry，则restart_index_ = X-1;
      //       - 否则current_ 指向Restart[X]中间的或最后的Entry，则restart_index_ = X;
      // it is in purpose: restart_index_ is used for `Prev()`; 这样要找current_的前一个Entry时，总能
      // 在Restart[restart_index_]中找。
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};

Iterator* Block::NewIterator(const Comparator* comparator) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(comparator, data_, restart_offset_, num_restarts);
  }
}

}  // namespace leveldb
